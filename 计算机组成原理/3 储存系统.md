# 储存系统

[TOC]

## 存储器概述

1. 分类：
   1. RAM（随机存储器）
   2. ROM（只读存储器）
   3. 串行访问储存器：磁盘属于直接存取储存器（DAM），磁带属于顺序存取储存器
2. **存取周期**：读写周期、访问周期，进行一次完整读写操作的时间，**=存取时间+恢复时间**
3. 相联存储器：一种可以根据存储内容来查找的存储器（也可以普通寻址），用于快表或者路由表等需要按内容查找等数据存储



## 半导体随机存储器

1. SRAM：静态随机存储器（用六晶体管MOS触发器），存取后不需要再生，存取速度快，集成度低，功耗大，一般用于CPU Cache

2. DRAM：

   1. 用栅极电容储存，密度比SRAM高
   2. 地址复用，只需要SRAM一半的地址线，行列地址分两次送入
   3. ==刷新==：
      1. 集中刷新：在一个刷新周期内，固定时间全部一起刷新，死区时间长
      2. 分散刷新：一个工作周期内，前半部分读写后半部分刷新，延长了存取周期，降低速度
      3. 异步刷新：刷新周期/行数求得两次刷新间隔，每t产生一次刷新请求，减少了刷新次数，提高了工作效率
   4. 常见缩写：
      * WE：读写线，一般高电平读取，低电平写入
      * CS：片选线

   4. 读写周期：
      1. 读周期：
      2. 写周期：

3. DRAM引脚数量计算：$引脚数=行/列地址线+数据线+读控制线+写控制线+行选线+列选线 \stackrel{一般情况}{\longrightarrow}行/列地址线+数据线+1+1+1+1$



## 只读存储器

|             类型             |                特点                 |
| :--------------------------: | :---------------------------------: |
|    掩模式只读存储器 MROM     |    无法改变内容，集成度高，便宜     |
|  一次可编程只读存储器 PROM   |             一次性编程              |
| 可擦除可编程只读存储器 EPROM |     多次且有限的改写 写入时间长     |
|          闪存 Flash          |            快速擦除重写             |
|             SSD              | 控制单元+闪存芯片 读写速度快 价格高 |

注意：

1. BIOS一般固化在ROM上用于引导存储在硬盘上的操作系统启动



## 主存储器的扩展/与CPU的连接

1. ==扩展==
   1. 位扩展：8片8K*1b把地址线并起来，成为8K\*8b，CS要连接到全部芯片
   2. 字扩展：4片16K\*8b使用两条片选信号线$A_{15},A_{14}$选择其中一片组成64K*8b，**00**00000000000000，前两位为片选，后14位为片内定位，CS通过译码器连接到各芯片
   3. 同时扩展：综合一下
2. 片选：
   1. 线选法：一片分配一根线，低电平说明选中
   2. 译码片选法：00-1，01-2，10-3，11-4，需要译码器

3. 连接题：
   1. 信号的转换：
      1. MERQ芯片选择信号激活三八译码器产生CS片选信号
      2. $A_n$地址线高x位在三八译码器译码后成为CS片选信号，例如高3位000地址可以产生8个片选信号
   2. **混合芯片**（如8K*8b+8\*K\*1b）：见课后习题3.4.5.2.5
      1. 搞清楚地址结构层次：片内地址有几位，要如何进行片选（与非门）
      2. 将小的芯片“封装”起来，看作为一个大型芯片



## 双端口RAM/多模块存储器

1. 双端口RAM冲突情况：
   * 读出错误：一个端口写入，另一端口读同一个地址
   * 写入错误：两个端口同时写入一个地址
   * **解决**：置BUSY信号为0，暂时关闭（延时）一个端口
2. 多模块存储器
   1. 单体多字：每个存储单元m字，总线宽度m字，一次读出m字，提高带宽但要求数据必须连续否则无法处理**转移指令**
   2. 多体并行：
      1. 高位交叉编址：高位地址为体号，模块内地址连续，访问连续块时总是先访问同一个模块。故仍然是串行存取，**不能提高吞吐率**
      2. ==低位交叉编址==：低位地址为体号，模块内地址跳跃，可以在一个模块存取周期的**恢复时间**内进行下一个模块的存取工作，方便实现流水线，**能提高带宽与吞吐率**
         1. 一个字存取周期为T，总线传送周期为r，则模块数大于等于$m=\frac{T}{r}$
         2. 连续存取m个字所需时间为：$t_1=T+(m-1)r$（做题时最好画出流水线图）
         3. 冲突：在一个滑动窗口内（大小通常是m）有相同模块被访问，则冲突



## 高速缓冲存储器

1. 平均访问时间：$T_a=Ht_c+(1-H)t_m,H:命中率$

2. 映射方式：

   1. 直接映射：$j=i\ mod\ 2^c,2^c：Cache中总块数$，如果冲突则无条件替换（无需替换算法）

      * 实现简单，冲突概率最高，空间利用率最低

      | 标记（m-c位） | Cache行号 | 块内地址 |
      | :-----------: | :-------: | :------: |

   2. ==全相联映射==：任意一块主存块都能装入Cache中的任意位置

      * 冲突概率低，空间利用率高，命中率高；运行速度较慢，成本高，需要相联存储器进行地址映射
      * 只保存Tag，**块内地址不存储**

      | 标记 | 块内地址 |
      | :--: | :------: |

   3. ==组相连映射==：$j=i\ mod\ Q$将Cache分为大小相同的组，一块数据能装入组内任意位置

      * 每组行越多，冲突概率越低，但成本越高；选择合适的组大小能使性能与全相联映射类似，成本接近直接映射
      * **Cache内地址结构**：Cache存储标记位+有效位+(脏位+替换算法位)，只保存Tag，组号，**块内地址不存储**

      | 标记 | 组号 | 块内地址 |
      | :--: | :--: | :------: |

3. ==替换算法==：

   1. 随机
   2. FIFO（先进先出）
   3. LRU（近期最少使用）

4. 写策略：

   1. 写命中时：
      1. 全写法：同时写入Cache和内存
      2. 写回法：只修改Cache，等Cache被换成时才写主存
   2. 写不命中：
      1. 写分配：加载未命中块至Cache，更新（想利用**空间局部性**）
      2. 非写分配法：只写入主存，不调动
   3. 现代计算机：L1写分配与写回法合用，L1对L2全写法，L2对主存写回法



## 虚拟存储器

1. 页表
   1. 有效位（装入位）：表示对应页面是否在主存中
   2. 脏位（修改位）：表示页面是否被修改，虚存使用回写机制
   3. 引用位（使用位）：配合替换策略（FIFO/LRU）进行设置
   4. 每个进程都有一个页表基址寄存器，存放高位虚拟页号对应的页表项
   5. 页表容易在最后一页中存在碎片
2. 快表
   1. 采用虚拟存储后，访问主存的次数更多了，需要TLB来提高效率
   2. ==虚地址的映射==：TLB标记的内容在全相联方式下就是该页表项对应的虚页号；组相联方式下则是对应虚页号的高位部分，虚页号的低位部分则为TLB组的组索引
   3. 快表和慢表可以同步进行查找，TLB命中时使慢表查找作废，使访问速度几乎没有下降
   4. Cache缺失由硬件处理；缺页处理由软件处理，即操作系统的「缺页异常处理程序」；TLB缺失则可以用硬件或软件进行处理，例如「TLB缺失异常处理程序」
3. 段表
   1. 段表比起页表多记录一个段长，因为段长可变
   2. 段表每段为逻辑独立的，比起页表易于编译管理和保护，但是段间容易存在碎片
   3. 段页式虚存好处是兼顾两者优点，坏处是地址变换中需要查两次表，系统开销大



## 零碎重点

1. `a[k]=a[k]+1`会访问两次内存，故第一次读未命中时，第二次写会命中，在计算代码命中率时应注意
2. 虚存与Cache的对比：
   1. 相同：提高性能、分块、映射、替换算法、局部性原理
   2. 不同：
      1. Cache主要解决系统速度，虚存主要解决主存容量
      2. **Cache全由硬件实现，对程序员透明；虚存由os和硬件实现，是逻辑上的，对系统程序员不透明（如汇编程序），但对应用程序员透明**
      3. 对于不命中时对性能的影响：CPU十倍于Cache，主存100倍于硬盘；故虚存不命中影响更大
      4. CPU与Cache、主存直连，而与辅存不直连，硬盘先调入主存，不与CPU直接通信

3. 