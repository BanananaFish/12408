# 数据的表示和运算

[TOC]

## 数制与编码

1. 任意进制互转：除基取余法（基：基数；余：余数，倒序即为转化后数字）
2. BCD码：
   1. 8421码
   2. 余3码：在8421基础上加$(0011)_2$形成
   3. 2421码
3. 校验码：
   1. 奇偶校验码
   2. ==海明码==
      1. $n_{有效信息位}+k_{检验位位数} \leq 2^k -1$ 如需要检测两位，则$n_{有效信息位}+k_{检验位位数} \leq 2^{k-1}-1$
      2. 校验位的海明号分布：$2^{i-1}$，如：$1、2、4、8$
      3. 分组方式：被检验数据位置 = 本组检验位海明号之和，如：$D_4(H_7)=P_3(H_4)+P_2(H_2)+P_1(H_1)$
      4. 各组求异或
   3. ==循环冗余校验码==
      1. 生成多项式：$x^3+x^2+1 \rightarrow (1101)_2$
      2. 左移最高次幂位
      3. 模2除法：余数R位加到2)中，为最终结果



## 定点数的表示与运算

1. 定点小数：$x_{sig}.x_1 x_2 x_3\dots$，小数点隐含在符号位之后

2. 补码符号扩展（负数）：原符号位保持不变，新附加位：1（整数），0（**小数**）

3. 溢出判断：

   * 单符号位：相运算两数，符号位相同而运算后符号位不同则发生溢出

     $$V=A_sB_s\overline{S_s}+\overline{A_sB_s}S_s$$

   * 双符号位：00/11无溢出，01/10为上溢出/下溢出

   * 单符号位+进位：符号位进位=最高位进位

4. ==原码、补码的乘法==

   1. 原码乘法：右移至乘数全部丢失

   2. 补码乘法：

      1. 符号位参与计算

      2. 采用补码进行计算

      3. 被乘数X一般取**双符号位**参与计算，并且让部分积初始值为0，长度与被乘数X相同，乘数Y 可取**单符号位**

      4. 开始计算时，乘数Y 末尾增设附加位（$Y_{n+1}$），值为0

      5. 位规则（移位看乘数后两位，部分积右移时补位看最高位）

      Booth算法的移位规则：比原码乘法多移一位

      | 高位 | 低位 |           操作            |
      | :--: | :--: | :-----------------------: |
      |  0   |  0   |      部分积右移一位       |
      |  0   |  1   | 部分积加$X_补$，右移一位  |
      |  1   |  0   | 部分积加$-X_补$，右移一位 |
      |  1   |  1   |      部分积右移一位       |

   3. 原码除法（加减交替法/不恢复余数法）：

      1. 符号位异或
      2. 被除数减去除数：
         * 余数为正：商1，余数、商左移一位，减去除数
         * 余数为负：商0，余数、商左移一位，加上除数



## 浮点数的表示与运算

1. 规格化：

   * 左规：运算结果的尾数为0.000xxx形式，需要算数左移，减去相应的阶码：规格化为x.xxxx形式
   * 右规：运算结果尾数溢出（用双符号位检测），算数左移，加阶码
   * 阶码对阶注意正负$-4\leq-3$，故-4向-3对阶

2. ==IEEE 754==:

   1. 格式：

      |   类型   | 数符 | 阶码（移码） | 尾数数值（原码） | 总位数 | 偏置值H |  D   |
      | :------: | :--: | :----------: | :--------------: | :----: | :-----: | :--: |
      | 短浮点数 |  1   | 8**(1~254)** |        23        |   32   |   7FH   | 127  |
      | 长浮点数 |  1   |      11      |        52        |   64   |  3FFH   | 1023 |

   2. 短浮点数真值：${-1}^S \times \textbf{1}.M \times 2^{E-127}$

   3. 注意：

      1. E-127，即阶码不可以取到0以及255：

         |    形式    |   阶码   |   尾数   |
         | :--------: | :------: | :------: |
         |     0      |    0     |    0     |
         | 尚未规格化 |    0     | $\neg 0$ |
         |  一般形式  | 非全0全1 |   任意   |
         |    无穷    |   全1    |    0     |
         |    NaN     |   全1    | $\neg0$  |

      2. 计算时的==规格化==：

         * 补码负数的最大值：1.011111……，故：$[-0.5]_补=1.1000$不是规格化数，应该左规为$[-1]_补=1.0000$
         * 右规/对阶过程中两种舍入：
           * 0舍入1:舍去的最高位为0则不处理，为1则在尾数加1（类似于四舍五入），加1后可能溢出，再次进行右规
           * 恒置1:恒让尾数为1

      3. 溢出判断：规格化后看阶码，只有阶码溢出才叫溢出故障（尾数溢出可以规格化）



## 算数逻辑单元（ALU）

1. 一位全加器：
   1. 和表达式：$S_i=A_i\oplus B_i \oplus C_{i-1}$
   2. 进位表达式：$C_i = A_iB_i+(A_i\oplus B_i)C_{i-1}$
2. 并行加法器：
   * 进位表达式：$C_i=G_i+P_iC_{i-1},其中：G_i=A_iB_i,P_i=A_i\oplus B_i$
   * $G_i$称为进位产生函数，$P_i$成为进位传递函数
   * 串行进位：$C_i=G_n+P_nC_{n-1}$低位进位直接影响高位运算时间，位数越多延迟越高
   * 并行进位：$C_i=G_i+P_iC_{i-1}$可把$C_{i-1}$展开，位数增加后加法器结构变复杂，需要结合串行：
     * 单级先行进位方式：组内并行，组间串行
     * 多级先行进位方式：组内并行，组间并行



## 零碎重点

1. 大端与小端：数0x1A2B3C4D

   |      | 0x01 | 0x02 | 0x03 | 0x04 | 0x05 | 0x06 | 0x07 | 0x08 |
   | ---- | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
   | 大端 |  1A  |  2B  |  3C  |  4D  |      |      |      |      |
   | 小端 |  4D  |  3C  |  2B  |  1A  |      |      |      |      |

2. 强制类型转换：

   1. 有/无符号数转换：改变编译器「解释」的方式
   2. 不同字长整数转换：短变长按符号位补足，长变短直接截断保留低位
   3. **int向float转换**：int共31位精度位，float共23位精度位（不含隐含「1」），故(float)int会丢失精度
   4. int/float向double转换，精确转换
   5. (double)float，精度丢失，**可能溢出**
   6. (int)double/float，向0方向截断，只保留整数部分，**可能溢出**

3. ==溢出==：

   1. 加法溢出
   2. 减法溢出
   3. 乘法溢出
   4. 除法溢出

4. 循环移位：

   * 不带CF的循环移位要复制一份到CF中
   * 带CF的循环移位CF跟随数据一起移动

5. 计算机在字长足够的情况下依然无法精确的表示每个数：例如1/3，只能用$\frac{1}{2^n}$组合来逼近

