# 树与二叉树

[TOC]

## 树的基本性质

1. $结点数=所有结点度数之和（分支数）+1$
2. $第i层最多有m^{i-1}个结点，m为度数$



## 二叉树

### 二叉树的概念

1. 满二叉树/完全二叉树：满二叉树为含有$2^h-1$结点的二叉树；完全二叉树为满二叉树删去最后几个叶子结点
2. **二叉树的性质**：
   1. $n_0=n_2+1$，用度之和加一等于结点总数来证明：$n_0+n_1+n_2=n_1+2n_2+1$
   2. $第i层最多有2^{i-1}个结点$
   3. 完全二叉树的结点深度为：$\lfloor \log_2{i} \rfloor+1$
   4. 具有n个结点的完全二叉树高度为：$\lceil \log_2(n+1) \rceil$或$\lfloor \log_2{}n \rfloor+1$



### 二叉树的存储

1. 顺序：用一维数组表示一个完全二叉树层次遍历的结果，如果不存在结点则用0等占位符表示

2. 链式：

   ```c
   typedef struct{
     int data;
     struct TreeNode *Lchild,*Rchild;//左右孩子指针
   }TreeNode,*biTree;
   ```



### 二叉树的遍历

1. 先序/中序/后序 - 深度优先搜索：

   1. **递归算法和非递归算法的转换**：使用栈

      例如：中序遍历：

      1. 左孩子依次入栈，直至左孩子为空
      2. 出栈一个结点，如果右孩子为空则重复2；如果不空则对右子树进行1

2. 层次遍历 - 广度优先搜索：使用队列

   1. 将根入队
   2. 只要队列不空，则出队，访问；如果出队结点左孩子不空则入队，右孩子不空则入队
   3. 队列为空时遍历结束

3. 线索二叉树的遍历：既不需要递归，也不需要栈/队列，以中序线索树为例

   1. 先找到中序遍历访问的第一个结点（最左下结点）：

      ```c
      ThreadNode * Firstnode(ThreadNode *p){
      	while(p->Ltag==0) p=p->Lchild;//只要左结点不是线索就一直往左
        return p;
      }
      ```

   2. 再通过线索访问该结点的直接后继：

      ```c
      ThreadNode * Nextnode(ThreadNode *p){
      	if(p->Rtag==0) return Firstnode(p->Rchild);//右结点不是线索则找右子树第一个中序遍历访问的结点
        else return p->Rchild;//直接返回右孩子
      }
      ```

   3. 使用循环遍历：

      ```c
      for(ThreadNode *p = Firstnode(Tree);p!=NULL;p=Nextnode){//初始化p为树中序遍历的第一个结点
        visit(p);
      }
      ```



## 树与森林

1. 孩子兄弟表示法：使用二叉树，一个结点的左结点表示他的第一个孩子，右结点表示他的兄弟

   ```c
   typedef struct{
     int data;
     struct *node Firstchild,Nextsibling;
   }CSNode,*CSTree;
   ```

   ps：森林也可以，只要把各树根看作是兄弟结点就行

2. 并查集

   1. 使用树的双亲表示法（孩子指向双亲），每个子集使用一棵树表示。使用一个双亲表示数组存放全集合：数组值指向双亲，数组下标代表集合名，根结点的双亲结点为负数



## 二叉排序树 BST

1. 删除
   1. 左子树不空，右子树空：左子女填补
   2. 左子树空，右子树不空：右子女填补
   3. 左右子树均不空：**用右子树上中序遍历的第一个结点**
2. 查找性能分析：
   1. 二叉平衡树：$ASL = O(\log_2n)$
   2. 二叉排序树的最坏情况（单支树）：$ASL = O(n)$
   3. 与二分查找的对比：
      1. 平均时间性能差不多
      2. 二分查找判定树是唯一的，而二叉排序树可能会因输入顺序导致生成结果不同
      3. 维护表的有序性：二叉排序树无需移动结点，只需修改指针；而二分查找对象为有序循序表，如果有插入删除操作，需要$O(n)$的时间复杂度
      4. **结论**：动态查找表适合二叉排序树，静态查找表适合顺序表然后使用二分查找



### 二叉平衡树

1. 平衡因子：$左子树高度-右子树高度$
2. 平衡二叉树的查找：有n结点的二叉树平均查找长度为$O(\log_2{n})$
3. **结点数递推**：$n_h=1+n_{h-1}+n_{h-2}$
4. 若平衡二叉树高为6，所有非叶子结点的平衡因子为1，则结点总数？
   1. 平衡因子为1则**结点数最少**（刚好平衡）
   2. T1 = 1；T2 = 2；T3 = 4；T4 = 7……T6 = 20

### 哈夫曼树

1. 选两个最小权构造成一个树，根结点为权值之和
2. 从结点和树根中选两个最小权，重复上一步
3. 叶子结点全部是权值结点
4. 新建了n-1个结点，结点总数为2n-1
5. 哈夫曼编码：前缀编码（没有一个编码是另一个编码的前缀），0/1标记为在哈夫曼树中转向左/右



## 零碎重点

1. 设二叉树有2n个结点，m<n则不可能有2m个度为1度结点：

   $n_1=2n-n_0-n_2=2(n-n_2)-1为奇数$

2. 一棵完全二叉树有1001个结点，其中叶结点的数目：

   最后一个分支结点：$\lfloor \frac{n}{2} \rfloor$

3. 一棵n个结点的二叉树，空指针数目为：$2n_{出结点的指针}-(n-1)_{分支数目}$

4. 中序遍历时，n在m前的条件是：在二叉树中，n在m左方

5. 后序遍历时，n在m前的条件是：在二叉树中，n为m的子孙（后序遍历能溯源/寻找路径）

6. 一棵非空二叉树先序和后序序列正好相反，则为一棵只有一个叶结点的二叉树（根左右的相反序列为右左根，与左右根只有一个根重合）
7. **线索二叉树是一种物理结构**：二叉树是一种逻辑结构，但线索二叉树为加上线索的链表结构，故是实际的物理存储结构
8. 先序序列为a,b,c,d对应的不同二叉树有几个？
   1. 先序+中序可唯一确定一个二叉树，故该题转换为几个中序序列
   2. 中序遍历可以看成结点出栈的**条件**为左孩子为空，入栈的**条件**为有左孩子，求4个结点能排列出几种出栈顺序：
   3. 卡特兰数：$\frac{1}{n+1}C_{2n}^n=$
9. **删除一个二叉树中值为x的结点，以及它的子树**
   1. 删除单个结点宜用递归，从下往上删除子树，最终删除整个子树
   2. 删除值为x的结点，需要遍历整个树，最省操作的遍历宜用层次遍历，不会导致重复配对与删除
10. 给定一棵树，可以找到唯一的一个二叉树与之对应
11. 一个森林有n个非终端结点，则其对应的二叉树有**几个右指针域为空**的结点？
    1. n个非终端结点的孩子全部转换为其左子树后，其最后一个一个孩子必定右指针域为空；
    2. 森林中最后一棵树的根结点转换后右指针域必为空；
    3. 故n+1个右指针域为空的结点
12. 森林有15边、25结点，其有几棵树？
    1. 添加一个虚拟根结点，使全部树的根与之相连 -> 共26个结点，则应该有25条边
    2. 25-15=10条虚拟边，则对应10棵树

## 一些骚操作

1. 二叉树自下而上，自右到左的层次遍历：用一个栈装正常层次遍历访问的结点，装满后直接全部出栈并访问

2. 交换二叉树的全部左右子树

   ```c
   void swap(biTree t){
     if(t){
       swap(t->Lchild);//递归交换左子树
       swap(t->Rchild);//递归交换右子树
       
       biNode *temp = t->Lchild;
       t->Lchild = t->Rchild;
       t->Rchild = temp;//交换左右子树
     }
   }
   ```

   