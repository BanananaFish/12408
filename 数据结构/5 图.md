# 图

[TOC]

## 概念

1. $G=(V,E),V'\subset V,E'\subset E,(V',E')不一定是G的子图，因为它就不一定是图（例如一个顶点不在V'而在E’内）$

2. 连通图：无向图中讨论连通性，有向图中讨论强联通性（双向通）
3. 无向非联通图下边数最多：n-1个顶点构成一个完全图，有一个顶点独立，此时再加一条边即是联通图
4. 有向强联通情况下：n条边，构成环路
5. 若无向图含有n个顶点，保证图任何情况下都是联通的，最小边数为：先保证n-1个完全联通：(n-1)(n-2)/2，再让剩下那个顶点连上去：(n-1)(n-2)/2 + 2



## 存储

1. 邻接矩阵：无向图一定是对称矩阵，上三角存出弧，下三角存入弧

2. 邻接表：无向图一条边会存两次，不唯一

3. 十字链表：有向图，不唯一

   1. 弧结点

      | tailvex(弧尾) | headvex(弧头) | hlink(弧头相同的弧) | tlink(弧尾相同的弧) | info |
      | ------------- | ------------- | ------------------- | ------------------- | ---- |

   2. 顶点（顶点间顺序存储）

      | data | firstin(第一条出弧) | firstout(第一条入弧) |
      | ---- | ------------------- | -------------------- |

      

4. 邻接多重表

   1. 有向图无向图都只会存一条边

      | mark(搜索标志位) | ivex(顶点) | ilink(指向该顶点的下一条边) | jvex | jlink | info |
      | ---------------- | ---------- | --------------------------- | ---- | ----- | ---- |



## 遍历：BFS与DFS

### BFS

1. 需要借助一个队列存储未访问的结点，无需回退，故不是递归算法
2. 可以求无权图的最短路径，每次访问则在上一个出队结点的路径上长度加一`dist[now]=dist[pre]+1`
3. 邻接矩阵唯一，BFS生成树唯一；邻接表不唯一，BFS生成树不唯一



### DFS

1. 回退，递归，递归深度$O(|V|)$
2. 同BFS.3
3. 联通图只需调用一次DFS/BFS；非联通的无向图每一个联通分量需调用一次DFS/BFS，有向图的非强联通分量无法在一次DFS/BFS中遍历。
4. DFS生成树为在非联通下应该是森林
5. 回路判断：DFS结束前：
   1. 无向图：遇到了回边
   2. 有向图：出现$u \rightarrow v$，而在生成树上$u$为$v$的子孙



### 性能

[BFS/DFS性能分析](./算法基础.md)



## 最小生成树

1. Prim：$O(|V|^2|)$，用于边稠密而顶点稀疏
2. Kruskal（并查集实现）：$O(|E|\log{|E|})$，用于边稀疏而顶点稠密
3. 破圈法：任取一圈，去掉圈上权值最大的边，直到无圈



1. 任意一个环内所包含边的权值均不相同时，最小生成树唯一



## 最短路

1. Dijkstra
   1. 性能：
      1. 邻接矩阵表示：$O(|V|^2)$
      2. 带权邻接表表示：修改dist数组时间减少但在dist中选择最小分量时间不变，时间复杂度不变
   2. 不适用于负权值图
2. Floyd
   1. 性能：$O(|V|^3)$，但代码简单因而常数系数小，在中等规模下仍有效
   2. 可对每一顶点当作源，使用n次Dijkstra来代替Floyd，时间复杂度同上
   3. 允许负权值图



## 拓扑排序/关键路径

1. 邻接表下，拓扑排序的时间复杂度：$O(|V|+|E|)$；邻接矩阵下，拓扑排序的时间复杂度：$O(|V|^2)$；
2. 拓扑排序可用栈/队列，只需暂存，不关注先后
3. 判断回环：拓扑排序中找不到下一个加入栈的结点
4. 一个有向图具有**有序**的拓扑排序序列，则它的邻接矩阵一定是三角
5. DFS遍历一个无环有向图，退栈时输出，则该序列为逆拓扑有序



1. **只有能覆盖到全部关键路径的活动时间减少时，才能缩短工期**；见题6.4.6.1.21