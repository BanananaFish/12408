# 线性表

[TOC]

## 顺序表示

1. 静态一维数组方式：

   1. 静态初始化定义：

      ```c
      #define MaxSize 50//静态数组最长长度
      typedef struct{
        int data[MaxSize];
        int length;//数组长度，用于越界检查
      }SqList;
      ```

   2. 动态初始化定义：

      ```c
      #define InitSize 30//初始化的长度
      typedef struct{
        int *data;//数组指针
        int MaxSize,length;//一个最大长度，用于限制
      }SeqList;
      
      L.data = (int *)malloc(sizeof(int)*InitSize);//初始化
      ```



## 链式表示

1. 单链表

   1. 定义：

      ```c
      typedef struct{
        int data;
        struct node *next;//指向下一个结点的指针，注意指针类型
      }node,*LinkList;//单链表名指向头结点/第一个结点
      
      LinkList L = (LinkList)malloc(sizeof(node));//有头结点的链表
      L->next = NULL;//初始化
      ```

   2. 头插法：在头结点后插入新结点

   3. 尾插法：使用尾指针，指向最后一个结点，每次将尾指针指向插入的新结点

   4. 技巧：

      1. 在一个结点后插入：

         ```c
         new_node->next = front_node->next;
         front_node->next = new_node;
         ```

      2. 在一个结点前插入（无双链表）：

         ```c
         new_node->next = next_node->next;
         next_node->next = new_node;//仍然插入到结点后
         swap(new_node->data,next_node->data);//交换数据域
         ```

         ps. 删除结点同样可以先复制数据然后删除后一个结点

2. 双链表：查找前驱结点更简单

3. 循环链表：空链表的头节点的next域为自身

4. 静态链表：a->b->c->d

   | 数组下标 |    数据    |        游标        |
   | :------: | :--------: | :----------------: |
   |    0     | （头指针） |         3          |
   |    1     |     d      | -1（链表最后一项） |
   |    2     |     b      |         4          |
   |    3     |     a      |         2          |
   |    4     |     c      |         1          |



## 顺序表VS链表

1. 读写：顺序表可顺序存取，也可**随机存取**；链表只能顺序存取
2. 逻辑结构/物理结构：顺序表逻辑上相邻时物理上也相邻；链表不一定
3. 查找/插入/删除：
   1. 按值查找：顺序表无序时$O(n)$，有序时使用折半查找$O(\log_2{n})$；链表$O(n)$
   2. 按序号查找：顺序表$O(1)$；链表$O(n)$



## 顺序表经典算法

1. 旋转数组（向左/右移动k位）：题2.2.3.2.10
   1. 辅助数组：创建辅助数组，复制原数组，利用模运算映射到旋转后位置
   2. 两次反转：先反转整个数组，再反转后/前k个元素，然后再反转剩余的
2. 中位数（两个等长、升序数组全部元素的中位数）：题2.2.3.2.11
   1. 归并排序后输出第2n/2位
   2. 双指针：设两数组A、B中位数分别为a、b
      1. a=b则为所求中位数
      2. a<b则舍弃A中小的一半，B中大的一半，两次舍弃长度相等
      3. a>b则舍弃A中大的一半，B中小的一半，两次舍弃长度相等
3. 主元素（数组中数量最多且过半的元素）：题2.2.2.3.2.12
   1. 哈希表：将A使用`count[A[i]]`映射到一个计数数组中，每次命中对应位置+1，遍历数组，找出计数大与length/2的最大值
   2. 扫描：
      1. 扫描数组，记录一个整数，如果后一个数与它相等，则计数+1，否则计数-1；计数为零时重新记录为下一个整数，扫描完后假设该整数为x
      2. 再次遍历数组，记录x个数，大于length/2则输出，否则输出-1
4. 未出现的最小正整数：题2.2.3.2.13
   1. 升序排序后，检查不连续位置
   2. 记录介于1～n的正整数：
      1. n个数中有不在1～n内的数：则1～n中必有空位，即为所求
      2. n个数恰好为1～n，则直接输出n+1



## 链表经典算法

1. 就地倒置一个链表：

   1. 遍历链表，将每个结点头插到最前

   2. 三指针，指向相邻的三个元素：pre、p、r

      ```c
      LinkList Reverse(LinkList L){
        Lnode *pre, *p = L->next, *r = p->next;
        p->next = NULL;//处理第一个结点，倒置后为尾结点，故next域为NULL
        while(r!=NULL){
          pre = p;
          p = r;
          r = r->next;//三个指针往后移动一位
          p->next = pre;//倒置指针
        }
        L->next = p;//处理最后一个元素
        return L;
      }
      ```

      ![草稿本-3](/Users/bananafish/Library/Mobile Documents/iCloud~md~obsidian/Documents/12408/数据结构/线性表.assets/草稿本-3.jpg)

2. 找到两个链表的**公共后缀**：题2.3.7.2.8、题2.3.7.2.22
   1. 双指针：表长之差：dist，A指向较长链表的dist位置，B指向较短链表的起始元素（表尾对齐）
      1. A不等于B：A、B向后移动一位
      2. A等于B：输出该结点之后的所有结点
3. 查找倒数第k结点：题2.3.7.2.21
   1. 指针p1、p2初始指向第一个结点；
   2. p1向后k位，p2不动；
   3. p1、p2同步后移至p1到尾；
   4. 输出p2->data
4. 判断单链表有环：
   1. 指针p1、p2初始指向第一个结点；
   2. （在p2->next != NULL时）p1每移动一位，p2移动两位；
   3. p1==p2时，有环；p1指向NULL时无环；//p1、p2指向同一个位置说明p2套了p1的圈！

## 零碎考点

1. 一个链表常用操作是在末尾插入结点和删除结点（栈），应选用：带头结点的双循环链表
2. 排序一个单链表：可以复制到数组中用快排，时间复杂度低于直接插入排序的$O(n^2)$